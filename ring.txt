var size = 16.1;

//diamond size
var length = 5.34;
var width = 5.28;
var depth = 4.13;



var parameters = {""};
var instructions = ["r_end", size, "angle_end", 45];


var detail = 32;
var continuity_mode = 1;

function ring_segment(parameters)
{
    {
        r_start = parameters._start;
        r_end = parameters.r_end;
        
        offset_start = parameters.offset_start;
        offset_end = parameters.offset_end;
        
        shape_start = parameters.shape_start;
        shape_end = parameters.shape_end;
        
        angle_start = parameters.angle_start;
        angle_end = parameters.angle_end;
        
        no_of_segments = parameters.no_of_segments;
    }
    
    r_increment = (r_end - r_start)/no_of_segments;
    offset_increment = (offset_end - offset_start)/no_of_segments;
    angle_increment = (angle_end - angle_start)/no_of_segments;
    
    {
        end_r = r_start;
        
        end_offset = offset_start;
        
        end_shape = shape_start;
        
        end_angle = angle_start;
    }
    
    for(var segment = 0; segment < no_of_segments; segment++)
    {
        start_r = end_r;
        r_end += r_increment;
        
        start_offset = end_offset;
        end_offset += offset_increment;
        
        start_angle = end_angle;
        end_angle += angle_increment;
        
        start_shape = shape_start;
        
        //generate increment shape
        for(var vertex = 0; vertex < start_shape.length && vertex < end_shape.length; vertex++)
        {
            shape_increment[vertex] = [ ((shape_end[vertex])[0] - (shape_start[vertex])[0])/no_of_segments,
                                        ((shape_end[vertex])[1] - (shape_start[vertex])[1])/no_of_segments];
        }
        
        //shape interpolation (and triangulation?)
        end_shape[0] = [(start_shape[0])[0] + (shape_increment[0])[0],
                        (start_shape[0])[1] + (shape_increment[0])[1]];
                        
        var end_radius = r_end + (end_shape[0])[1];
            
        points[points.length] = [(end_shape[0])[0], cos(end_angle + 90)*end_radius, sin(end_angle + 90)*end_radius];
            
            
        for( vertex = 1; vertex < start_shape.length && vertex < end_shape.length; vertex++)
        {
            //generate next vertex
            end_shape[vertex] = [   (start_shape[vertex])[0] + (shape_increment[vertex])[0],
                                    (start_shape[vertex])[1] + (shape_increment[vertex])[1]];
            
            end_radius = r_end + (end_shape[vertex])[1];
            
            points[points.length] = [(end_shape[vertex])[0], cos(end_angle + 90)*end_radius, sin(end_angle + 90)*end_radius];
            
            
        }
    }
    
    return [points, triangles];
}

function main()
{
    var p;
    var t;
    
    for(var i = 0; i+1 < instructions.length; i+=2)
    {
        switch(instructions[i])
        {
            case "angle_end":
                
            parameters.angle_end = instruction[i+1];
            
            var model = ring_segment(parameters);
            
            //add to lists
            var j;
            for(j = 0; j < model[0].length; j++)
            {
                p[p.length] = (model[0])[j];
            }
            
            for(j = 0; j < model[1].length; j++)
            {
                t[t.length] = (model[1])[j];
            }
            
            //respect continuity mode
            if(continuity_mode > 0)
            {
                r_start = r_end;
                
                offset_start = offset_end;
                
                angle_start = angle_end;
                
                shape_start = shape_end;
            }
            
            break;
            
            case "set_detail":
            
            detail = instruction[i+1];
            
            break;
            
            case "set_continuity_mode":
            
            continuity_mode = instruction[i+1];
            
            break;
            
            
        }
        
    }
    
    var result = polyhedron({"points":p, "triangles":t});
    
    
    
    return result;
}
