var size = 16.1;

//diamond size
var Length = 5.34;
var width = 5.28;
var depth = 4.13;


var instructions = ["r_end", size, "angle_end", 45];

var detail = 128;
var continuity_mode = 1;
var parameters = {  angle_start : 0, andle_end : 90,
                    shape_start : [[1,0],[0,1],[-1,0]], shape_end :  [[1,0],[0,1],[-1,0]],
                    offset_start: 0, offset_end : 0,
                    r_start : size, r_end : size
};

function ring_segment()
{
    var points = [];
    var triangles = [];
    
    var r_start = parameters.r_start;
    var r_end = parameters.r_end;
    
    var offset_start = parameters.offset_start;
    var offset_end = parameters.offset_end;
    
    var shape_start = parameters.shape_start;
    var shape_end = parameters.shape_end;
        
    var angle_start = parameters.angle_start;
    var angle_end = parameters.angle_end;
    
    var no_of_segments = (angle_end - angle_start)/360*detail;
    
    var r_increment = (r_end - r_start)/no_of_segments;
    var offset_increment = (offset_end - offset_start)/no_of_segments;
    var angle_increment = (angle_end - angle_start)/no_of_segments;
    
    var end_r = r_start;
    
    var end_offset = offset_start;
    
    var end_shape = shape_start;
    
    var end_angle = angle_start;
    
    //generate increment shape and starting shape
    var shape_increment = [];
    var vertex;
    for(vertex = 0; vertex < shape_start.length && vertex < end_shape.length; vertex++)
    {
        shape_increment[vertex] = [  (shape_end[vertex][0] - shape_start[vertex][0])/no_of_segments,
                                     (shape_end[vertex][1] - shape_start[vertex][1])/no_of_segments];
    }
    
    for(vertex = 0; vertex < shape_start.length; vertex++)
    {
        shape_start[vertex] = [ shape_start[vertex][0] + offset_start,
                                cos(angle_start + 90)*(r_start + shape_start[vertex][1]),
                                sin(angle_start + 90)*(r_start + shape_start[vertex][1])];
    }
    
    //for(var segment = 0; segment < no_of_segments; segment++)
    //{
    //    var start_r = end_r;
    //    end_r += r_increment;
        
    //    var start_offset = end_offset;
    //    end_offset += offset_increment;
        
    //    var start_angle = end_angle;
    //    end_angle += angle_increment;
        
        //shape interpolation (and triangulation?)
        //end_shape[0] = [shape_start[0][0] + shape_increment[0][0],
        //               shape_start[0][1] + shape_increment[0][1]];
                        
        //var end_radius = r_end + end_shape[0][1];
            
        //points[points.length] = [end_shape[0][0], cos(end_angle + 90)*end_radius, sin(end_angle + 90)*end_radius];
            
            
    //     for( vertex = 1; vertex < start_shape.length && vertex < end_shape.length; vertex++)
    //     {
    //         //generate next vertex
    //         end_shape[vertex] = [   start_shape[vertex][0] + shape_increment[vertex][0],
    //                                 start_shape[vertex][1] + shape_increment[vertex][1]];
            
    //         end_radius = r_end + (end_shape[vertex])[1];
            
    //         points[points.length] = [end_shape[vertex][0], cos(end_angle + 90)*end_radius, sin(end_angle + 90)*end_radius];
            
    //     //triangulate
    //         triangles[triangles.length] = [points.length - 1 - shape_start.length,
    //                                       points.length - 1,
    //                                       points.length];
            
    //         triangles[triangles.length] = [points.length - 1 - start_shape.length,
    //                                       points.length - start_shape.length,
    //                                       points.length];
    //     }

    //    start_shape = end_shape;
    //}
    
    return {points: shape_start, triangles: [[0,2,1]]};
}

function main()
{
    // var p;
    // var t;
    
    // for(var i = 0; i+1 < instructions.length; i+=2)
    // {
    //     switch(instructions[i])
    //     {
    //         case "angle_end":
                
    //         parameters.angle_end = instructions[i+1];
            
    //         var model = ring_segment();
            
    //         //add to lists
    //         var j;
    //         for(j = 0; j < model[0].length; j++)
    //         {
    //             p[p.length] = (model[0])[j];
    //         }
            
    //         for(j = 0; j < model[1].length; j++)
    //         {
    //             t[t.length] = (model[1])[j];
    //         }
            
    //         //respect continuity mode
    //         if(continuity_mode > 0)
    //         {
    //             r_start = r_end;
                
    //             offset_start = offset_end;
                
    //             angle_start = angle_end;
                
    //             shape_start = shape_end;
    //         }
            
    //         break;
            
    //         case "set_detail":
            
    //         detail = instructions[i+1];
            
    //         break;
            
    //         case "set_continuity_mode":
            
    //         continuity_mode = instructions[i+1];
            
    //         break;
            
            
    //     }
        
    // }
    
    var model = ring_segment();
    var result = polyhedron({"points":model.points, "triangles":model.triangles});
    
    
    
    return result;
}
