var size = 16.1;

//diamond size
var Length = 5.34;
var width = 5.28;
var depth = 4.13;


var instructions = ["r_end", size, "angle_end", 45];

var detail = 128;
var continuity_mode = 1;
var parameters = {  angle_start: 30, angle_end: 330,
                    shape_start: [[1,0],[0,1],[-1,0]], shape_end:  [[1,0],[0,1],[-1,0]],
                    offset_start: -2.5, offset_end: 2.5,
                    r_start: size, r_end: size
};

function ring_segment()
{
    var points = [];
    var triangles = [];
    
    var r_start = parameters.r_start;
    var r_end = parameters.r_end;
    
    var offset_start = parameters.offset_start;
    var offset_end = parameters.offset_end;
    
    var shape_start = parameters.shape_start;
    var shape_end = parameters.shape_end;
        
    var angle_start = parameters.angle_start;
    var angle_end = parameters.angle_end;
    
    var no_of_segments = (angle_end - angle_start)/360*detail;
    
    var r_increment = (r_end - r_start)/no_of_segments;
    var offset_increment = (offset_end - offset_start)/no_of_segments;
    var angle_increment = (angle_end - angle_start)/no_of_segments;
    
    var end_r = r_start;
    
    var end_offset = offset_start;
    
    var end_shape = shape_start;
    
    var end_angle = angle_start;
    
    var vertex;
    
    //generate increment shape and starting shape
    var shape_increment = [];
    for(vertex = 0; vertex < shape_start.length && vertex < end_shape.length; vertex++)
    {
        shape_increment[vertex] = [  (shape_end[vertex][0] - shape_start[vertex][0])/no_of_segments,
                                     (shape_end[vertex][1] - shape_start[vertex][1])/no_of_segments];
    }
    
    for(vertex = 0; vertex < shape_start.length; vertex++)
    {
        points[points.length] = [ shape_start[vertex][0] + offset_start,
                                cos(angle_start + 90)*(r_start + shape_start[vertex][1]),
                                sin(angle_start + 90)*(r_start + shape_start[vertex][1])];
    }
    
    for(var segment = 0; segment < no_of_segments; segment++)
    {
        var start_r = end_r;
        end_r += r_increment;
        
        var start_offset = end_offset;
        end_offset += offset_increment;
        
        var start_angle = end_angle;
        end_angle += angle_increment;
        
        //shape interpolation (and triangulation?)
        for( vertex = 0; vertex < shape_start.length && vertex < end_shape.length; vertex++)
        {
            //generate next vertex
            end_shape[vertex] = [  shape_start[vertex][0] + shape_increment[vertex][0],
                                   shape_start[vertex][1] + shape_increment[vertex][1]];
            
            points[points.length] = [   end_shape[vertex][0] + end_offset,
                                        cos(end_angle + 90)*(end_r + end_shape[vertex][1]),
                                        sin(end_angle + 90)*(end_r + end_shape[vertex][1])];
            
            //triangulate
            if(vertex !== 0)
            {
                triangles[triangles.length] = [ points.length - 2 - shape_start.length,
                                                points.length - 2,
                                                points.length - 1];
            
                triangles[triangles.length] = [ points.length - 2 - shape_start.length,
                                                points.length - 1,
                                                points.length - 1 - shape_start.length];
            }
        }
        
        //cap underside
        triangles[triangles.length] = [ points.length - end_shape.length - shape_start.length,
                                        points.length - 1,
                                        points.length - end_shape.length];
                                        
        triangles[triangles.length] = [ points.length - end_shape.length - shape_start.length,
                                        points.length - end_shape.length -1,
                                        points.length - 1];

        shape_start = end_shape;
    }
    
    return {points: points, triangles: triangles};
}

function main()
{
    // var p;
    // var t;
    
    // for(var i = 0; i+1 < instructions.length; i+=2)
    // {
    //     switch(instructions[i])
    //     {
    //         case "angle_end":
                
    //         parameters.angle_end = instructions[i+1];
            
    //         var model = ring_segment();
            
    //         //add to lists
    //         var j;
    //         for(j = 0; j < model[0].length; j++)
    //         {
    //             p[p.length] = (model[0])[j];
    //         }
            
    //         for(j = 0; j < model[1].length; j++)
    //         {
    //             t[t.length] = (model[1])[j];
    //         }
            
    //         //respect continuity mode
    //         if(continuity_mode > 0)
    //         {
    //             r_start = r_end;
                
    //             offset_start = offset_end;
                
    //             angle_start = angle_end;
                
    //             shape_start = shape_end;
    //         }
            
    //         break;
            
    //         case "set_detail":
            
    //         detail = instructions[i+1];
            
    //         break;
            
    //         case "set_continuity_mode":
            
    //         continuity_mode = instructions[i+1];
            
    //         break;
            
            
    //     }
        
    // }
    
    var model = ring_segment();
    var result = polyhedron({"points":model.points, "triangles":model.triangles});
    
    
    
    return result;
}
