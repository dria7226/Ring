var size = 16.1;

//diamond size
var length = 5.34;
var width = 5.28;
var depth = 4.13;

var detail = 32;

function ring_band(parameters)
{
    {
        r_start = parameters._start;
        r_end = parameters.r_end;
        
        offset_start = parameters.offset_start;
        offset_end = parameters.offset_end;
        
        shape_start = parameters.shape_start;
        shape_end = parameters.shape_end;
        
        angle_start = parameters.angle_start;
        angle_end = parameters.angle_end;
        
        position_start = parameters.position_start;
        position_end = parameters.position_end;
        
        no_of_segments = parameters.no_of_segments;
    }
    
    r_increment = (r_end - r_start)/no_of_segments;
    offset_increment = (offset_end - offset_start)/no_of_segments;
    angle_increment = (angle_end - angle_start)/no_of_segments;
    position_increment = (position_end - position_start)/no_of_segments;
    
    {
        end_r = r_start;
        
        end_offset = offset_start;
        
        end_shape = shape_start;
        
        end_angle = angle_start;
        
        end_position = position_start;
    }
    
    for(var segment = 0; segment < no_of_segments; segment++)
    {
        start_r = end_r;
        r_end += r_increment;
        
        start_offset = end_offset;
        end_offset += offset_increment;
        
        start_angle = end_angle;
        end_angle += angle_increment;
        
        start_position = end_position;
        end_position += position_increment;
        
        start_shape = shape_start;
        
        //generate increment shape
        for(var vertex = 0; vertex < start_shape.length && vertex < end_shape.length; vertex++)
        {
            shape_increment[vertex] = [ ((shape_end[vertex])[0] - (shape_start[vertex])[0])/no_of_segments,
                                        ((shape_end[vertex])[1] - (shape_start[vertex])[1])/no_of_segments];
        }
        
        //shape interpolation (and triangulation?)
        end_shape[0] = [(start_shape[0])[0] + (shape_increment[0])[0],
                        (start_shape[0])[1] + (shape_increment[0])[1]];
                        
        var end_radius = r_end + (end_shape[0])[1];
            
        points[points.length] = [(end_shape[0])[0], cos(end_angle + 90)*end_radius, sin(end_angle + 90)*end_radius];
            
            
        for( vertex = 1; vertex < start_shape.length && vertex < end_shape.length; vertex++)
        {
            //generate next vertex
            end_shape[vertex] = [   (start_shape[vertex])[0] + (shape_increment[vertex])[0],
                                    (start_shape[vertex])[1] + (shape_increment[vertex])[1]];
            
            end_radius = r_end + (end_shape[vertex])[1];
            
            points[points.length] = [(end_shape[vertex])[0], cos(end_angle + 90)*end_radius, sin(end_angle + 90)*end_radius];
            
            
        }
    }
    
    return [points, triangles];
}

function main()
{
    var p;
    var t;
    for(var i = 0; i < instructions.length; i+=2)
    {
        switch(instructions[i])
        {
            case "r_end":
                
            break;
            
        }
        
    }
    
    var result = polyhedron({points:p, triangles:t});
    
    return result;
}
